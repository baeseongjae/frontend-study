# 💟 01/03 문제 💟

```
🤔 script는 parsing을 멈추는데 그이유는?

👉🏻 JS가 실행될때는 DOM, CSSOM이 변경될 수 있기때문에 JS실행이 끝난 후에 다시 parsing을 시작하여 변경된 DOM과 CSSOM을 반영한다(HTML parser는 script태그르 만나면 렌더링 제어 권한을 자바스크립트 엔진에게 넘겨주고, 파싱을 중단한다


🤔 element를 이동할 때 top, left vs  translate 최적의 방법은?

 👉🏻 top, left → layout+paint+composition
 👉🏻 translate → composition만 발생
```

<hr>

<br>
<br>

# 📝 브라우저 동작원리

# 1. 탐색 (Navigation)

웹페이지를 로딩하는 첫 단계로, 주소창에 **URL을 입력하거나, 링크를 클릭하고, 폼(form)을 제출**같은 사용자의 요청때마다 발생한다.

### DNS?

Domain Name System: 도메인에 속하는 IP주소가 포함된 매핑 테이블이 저장된 서버로써, DNS 서버는 사용자가 입력한 도메인 주소를 해당하는 IP 주소로 해석하는 역할을 합니다.

### IP주소?

IP주소는 컴퓨터 네트워크에서 **장치를 식별하고 통신을 위한 주소**를 제공하는 숫자로 된 고유한 식별자입니다. 인터넷상에서 데이터를 주고받을 때, 각 장치는 IP 주소를 사용하여 목적지를 식별하고 통신합니다.

## 1) DNS 조회(DNS Lookup)

웹 페이지를 탐색하는 첫 단계는 **해당 페이지의 자원이 어디에 위치하는지** 찾는 것입니다.

(만약 `https://example.com`를 탐색한다면 HTML 페이지는 IP 주소가 `93.184.216.34`인 서버에 위치한다.만약 이 사이트를 한 번도 방문한 적이 없다면 DNS 조회가 필요)

브라우저는 DNS 조회 요청 → 서버는 IP 주소로 응답

(DNS 조회는 보통 호스트 이름 하나당 한 번만 수행됩니다. 하지만 DNS 조회는 요청된 페이지에서 참조하는 다른 호스트 이름에 대해서는 각각 수행해야합니다. 만약 글꼴, 이미지, 스크립트, 광고 그리고 다른 자원들이 서로 다른 호스트 이름을 가지고 있다면, DNS 조회는 각각에 대해서 모두 수행되어야 한다)

## 2) TCP handshake

IP 주소를 알고난 후에, 브라우저-서버는 TCP 3방향 handshake를 통해 연결을 설정

TCP(Transmission Control Protocol)?

네트워크에서 데이터를 안정적으로 전송하기 위한 프로토콜 중 하나로, OSI 모델에서 전송(transport) 계층에 위치하며, 신뢰성 있는 연결 지향형 통신을 제공. 이것은 데이터를 나누어 보내고, 받은 데이터에 대한 확인을 수행하여 데이터의 손실이나 손상을 방지합니다.

- **TCP:** 연결 지향형 프로토콜이며, 통신을 시작하기 전에 두 호스트 간에 연결을 설정하고, 통신이 완료되면 연결을 정리합니다.
- **UDP:** 비연결 지향형 프로토콜로, 연결 설정 및 해제가 필요하지 않습니다. 각각의 패킷은 독립적으로 처리되며, 개별 패킷 간의 순서가 보장되지 않습니다.

TCP의 3방향 핸드셰이크 기술은 "SYN-SYN-ACK" (더 정확히는 SYN, SYN-ACK, ACK)로 불리기도 합니다. 두 컴퓨터 간 TCP 세션을 협상하고 시작하기 위해서 TCP가 3개의 메세지를 전달하기 때문입니다. 이는 요청이 보내지기 전에 3개의 추가적인 메세지가 컴퓨터 사이에 주고받아진다는 의미다.

데이터를 전송하기 전에 (주로 HTTPS를 통해서) 통신하려는 두 주체(이 경우에는 브라우저와 웹 서버)가 TCP 소켓 연결을 위한 매개변수를 주고 받을 수 있도록 만들어졌습니다

### TLS 협상(TLS Negotiation

HTTPS를 이용한 **보안성있는 연결**을 위해서는 또 다른 "핸드셰이크"가 필요합니다. (TLS협상이라고 할 수 있는) 이 핸드셰이크는 **통신 암호화에 쓰일 암호를 결정**하고, 서버를 확인하고, 실제 데이터 전송 전에 안전한 연결이 이루어지도록 합니다. 이를 위해서 자원에 대한 실제 요청 전에 클라이언트에서 서버로 3번 더 왕복해야합니다.
<br>
<br>

# 2. 응답 (Response)

웹서버로 한 번 연결이 성립되고 나면, 브라우저는 HTTP GET request를 보낸다!

웹사이트는 HTML을 요청하고, 서버는HTML의 내용을 응답하게 된다.

### HTTP?

: 웹 브라우저가 웹 서버에게 특정 리소스(문서, 이미지, 데이터 등)를 요청하는 프로세스를 나타냅니다. HTTP(HyperText Transfer Protocol)는 클라이언트(브라우저)와 서버 간에 데이터를 전송하기 위한 프로토콜이다.
<br>
<br>

# 3. 구문분석 (Parsing)

브라우저가 받은 데이터를 DOM/CSSOM으로 바꾼다.

## 1) DOM 트리 구축

- DOM Tree는 완전하게 파싱된 HTML 페이지의 Object 표현이다.
- html로부터 시작해 각 element, text에 대한 node가 만들어진다.

<br>

### 프리로드 스캐너(Preload scanner)

DOM 트리를 만드는 프로세스는 메인 쓰레드를 차지하고, 프리로드 스캐너는 HTML의 우선순위가 높은 리소스(link의 CSS, Javscript, font 등)에 대해 요청을 해놓는다. 얘가 뒤에서 미리 요청해놓은 덕분에 구문 분석기가 요청되는 자원에 다다를 때 쯤이면 이미 그 자원들을 전송받고 있거나 이미 전송받은 후일 것입니다.
**프리로드 스캐너가 제공하는 최적화는 블록킹을 줄여줍니다.**

```
<link rel="stylesheet" src="styles.css" />
<script src="myscript.js" async></script>
<img src="myimage.jpg" alt="image description" />
<script src="anotherscript.js" async></script>
```

### 2) CSSOM

CSS를 처리하고 CSSOM 트리를 만드는 것입니다. CSS 객체 모델은 DOM과 비슷합니다. DOM과 CSSOM은 둘 다 트리구조이다.

### 3) 그 외 작업들

**JS compile**

: CSS가 분석되고 CSSOM이 생성되는 동안, 프리 스캐너 덕에 Javascript 파일 같은 다른 자원도 다운로드 됩니다.

**접근성 트리 구축(AOM)**

: 보조 장치는 이 트리를 이용해 내용을 분석하고 해석합니다. 접근성 객체 모델(AOM)은 DOM의 의미 버전입니다. 브라우저는 DOM이 업데이트 될 때 접근성 트리도 업데이트 합니다.

# 4. 렌더(Render)

<br>

## 1) render tree

: DOM과 CSSOM이 합쳐진 것으로 페이지에서 최종적으로 렌더링할 내용을 나타내는 Tree, 보여지는 노드만 생성! (display: none 속성은 렌더트리에 포함x)

## **2) Layout**

: 요소들이 페이지에서 배치되는 위치와 방법, 각 요소의 너비와 높이, 위치를 결정한다.

✓ 처음이면 layout, 다시 계산은 reflow

## 3) Paint

브라우저는 레이아웃 단계에서 계산된 각 박스를 실제 화면의 픽셀로 변환하고, 레이아웃 트리의 요소를 레이어로 분리할 수 있다. 레이어를 분할하면, 페인트, 리페인트 기능을 메인쓰레드가 돌아가는 CPU가 아닌 GPU가 나눠서 처리하기 때문에 성능이 향상된다고 한다. 메모리는 많이 소요하므로, 너무많은 레이어는 지양한다.

## 4) Composition

각 레이어를 조합하여 최종 화면을 생성한다.

💡 문서의 각 섹션이 다른 레이어에서 그려질 때, 섹션을 겹쳐놓으면서 그것들이 올바른 순서로 화면에 그려지는 것과 정확한 렌더링을 보장하기 위해 합성이 필요하다고 한다.
<br>
<br>
<br>
<br>
<br>

## 브라우저 동작 flow

1. **사용자가 URL(도메인) 입력**
2. **DNS 조회**
   - 브라우저는 입력받은 도메인 이름을 IP 주소로 변환하기 위해 DNS(Domain Name System) 서버에 조회를 요청하고, DNS서버는 IP주소로 응답한다.
3. **TCP 연결, handshake**
   - 브라우저는 서버로의 TCP handshake로 데이터를 안전하게 전송할 수 있도록 한다.
4. **HTTP 요청 전송:**
   - TCP 연결이 설정되면, 브라우저는 HTTP 요청을 통해 서버에게 웹 페이지, 리소스를 요청한다.
5. **서버 응답 및 데이터 수신:**
   - 서버는 브라우저의 요청에 응답하고 필요한 리소스들을 전송한다.
6. **HTML Parsing 및 DOM 생성:**
   - 브라우저는 받은 HTML 문서를 파싱하여 DOM(Document Object Model)을 생성한다.
7. **CSS Parsing 및 CSSOM 생성:**
   - 브라우저는 받은 CSS 파일을 파싱하여 CSSOM(CSS Object Model)을 생성한다.
8. **Render Tree 생성**
   - DOM과 CSSOM이 완성되면, Render Tree를 생성하고, 이 트리는 실제로 화면에 표시될 요소들의 계층 구조이다
9. **레이아웃(Layout):**
   - 렌더 트리를 기반으로 브라우저는 각 요소의 크기와 위치를 계산한다.
10. **페인트(Paint):**
    - 레이아웃을 기반으로 화면에 픽셀로 페인팅한다.
11. **페인트 및 레이아웃 계산 최적화:**
    - 브라우저는 페인트 및 레이아웃 계산을 최적화한다.
12. **페이지 표시:**
    - 최종적으로 렌더링이 완료되면 브라우저는 사용자에게 완성된 페이지를 표시한다.
