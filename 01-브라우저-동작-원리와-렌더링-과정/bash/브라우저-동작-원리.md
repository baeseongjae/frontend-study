# 브라우저 주소창에 URL을 입력하면??

- URL을 해석하고 서버와 통신하는 네트워크 관점
- 그리고 렌더링과정을 진행하는 프론트엔드 관점

## 네트워크 관점

​
URL을 해석하여  
**1\. 'www.naver.com' 을 호스팅하는 서버의 ip주소 찾기**  
\=> 이를 위해 브라우저가 URL을 해석하고 DNS 조회하는데, 바로 질의를 하는것이 아니다.  
\=> 한번 질의한 도메인을 계속 질의하면 성능면에서 안좋으므로.
​

```
1. 자신의 Hosts 파일에서 도메인 네임에 대응하는 ip 주소가 있는지 먼저 확인.
2. 로컬 DNS 캐시 확인
3. DNS 쿼리
4. IP주소 획득
```

​
**2.해당서버와 통신**
​

```
5. 서버와 TCP 연결 (3-way handshake)
6. HTTP Request
7. HTTP Response
```

참고: https://maxkim-j.github.io/posts/packet-travel/

cf. OSI 7계층 레이어 생각하기  
3계층 IP -> 4계층 TCP -> 7계층 HTTP
​
![](https://velog.velcdn.com/images/dallae28/post/1bba5b09-e312-4e6e-872f-06d4f6ecb305/image.png)
​

## 프론트엔드 관점

​
서버에서 응답받은 리소스들을 기반으로 파싱/렌더링을 수행한다.
​

```
1. 렌더엔진이 HTML과 CSS를 파싱하여 각각 DOM 트리와 CSSOM트리를 생성한다.
​
2. DOM트리와 CSSOM트리를 결합하여 render 트리를 만든다.
    (보이지 않는 엘리먼트는 포함되지 않는다. e.g. display:none;)
​
3. 렌더트리를 기반으로 Layout을 계산 (여기서 position, height등 계산됨)
​
4. 마지막으로 Paint 과정을 거쳐 렌더링 완성
```

​
이때 특정 인터렉션에 의해 DOM에 변화가 생기면 render Tree가 재생성되어 3번 4번 과정에서 각각 reflow, repaint가 발생한다.

<br>

## cf. URL과 URI의 차이.

- URL(Uniform Resource Locator)

  URI의 하위개념으로, 특정 주소의 리소스를 어떻게 가져올 것인가에 대한 구체 정보가 담겨있다.<br>
  예를들어, google.com은 URI이다! 그저 리소스를 식별하는 이름이다.

  http://www.google.com 은 자원의 이름뿐 아니라, 어떻게 접근하는지 스킴까지 있기 때문에 URL이다.

  http://www.google.com/network/index.html 라는 url이 있다면,
  www.google.com 이라는 서버에 http 요청을 하는거다. <br>
  (너네가 인터넷에 공개한 network 디렉토리 안에 있는 index.html이라는 파일을 http 응답을 통해 보내줘!)

  URL의 구성은 다음과 같이 이루어진다.
  <스킴>://<호스트명>/<경로명>

- URI(Uniform Resource Identifier)

  URI는 인터넷상 리소스를 식별하기 위한 식별자일 뿐이다.

  URI는 URL을 포함하는 정의로,<br>
  한마디로 URL은 찾고싶은 리소스의 실제 위치정보이고, URI는 위치에 관계없이 그저 자원을 식별한다.

<br>

# TCP와 UDP

### **TCP**(Transmission Control Protocol)

**TCP의 특징**

- 가상회선 패킷 교환방식 --> 순서보장
- 연결지향 ( 3-way handshake)
- 신뢰성
- 흐름제어
- 혼잡제어

하지만 단점으로는 최소처리량을 보장하지 않고, 속도가 UDP에 비해 느리다.

_흐름제어란?_

데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것입니다

_혼잡제어란?_

네트워크 내의 패킷수가 넘치지 않도록 방지.

#### **TCP 연결 성립 및 해제 과정**

**TCP Connection**

1\. SYN 단계 (클라이언트 -> 서버)

서버에 접속을 요청하는 SYN 패킷 전송 후 SYN_SENT 상태가 된다.

2.  SYN+ACK 단계 (서버-> 클라이언트)

ACK : 요청을 수락했다는 메시지

SYN : 접속 요청 프로세스인 클라이언트도 포트를 열어달라는 메시지

3\. ACK 단계(클라이언트-> 서버)

클라이언트는 서버의 응답을 받았다는 의미로 , 서버의 ISN+1 하여 다시 서버로 ACK를 보낸다.

ACK를 보내고 클라이언트는 ESTABLISHED 상태로 변경, 서버도 ACK 받고 ESTABLISHED로 상태 변경

| 상태         |                                          |
| ------------ | ---------------------------------------- |
| CLOSED       | 닫힌상태                                 |
| LISTEN       | 포트가 열린 상태로 연결 요청 대기중      |
| SYN_SENT     | SYN 요청을 한 상채                       |
| SYN_RECEIVED | SYN 요청을 받고 상대방의 응답 기다리는중 |
| ESTABLISHED  | 연결이 확인된 상태                       |

### **UDP**(User Datagram Protocol)

데이터그램 패킷 교환방식 사용.---> 순서 보장X

신뢰성 없다.

UDP는 비연결형 프로토콜로서, 에러검사 등 신뢰성과 관련된 기능들을 제공하지 않아 Best Effort service 라고 불린다.

("최선을 다할게 하지만 결과는 보장못함"..ㅋㅋ)

장점: 오버헤드가 작고 지연시간이 짧다.(전송속도 빠름)

온라인게임, 스트리밍서비스 등 신뢰성보다는 성능이 중요시되는 경우에 사용.

|                | TCP            | UDP             |
| -------------- | -------------- | --------------- |
| 연결방식       | 연결형 서비스  | 비연결형 서비스 |
| 패킷 교환 방식 | 가상 회선 방식 | 데이터그램 방식 |
| 순서보장       | 전송 순서 보장 | 순서보장X       |
| 신뢰성         | 신뢰성 높음    | 신뢰성 낮음     |
| 속도           | 느림           | 빠름            |

<br>

# TCP/IP 4계층 모델

OSI계층이 좀더 학문적인 느낌이라면, OSI 이론을 실제로 실무에서 사용하는 인터넷 표준이 TCP/IP 4계층이다.

**TCP/IP 프로토콜**

상위 계층 TCP : 메시지나 파일을 좀 더 작은 패킷으로 나누어 전송하고, 받은 패킷은 원래의 메시지로 조립하는 일 담당.<br>
하위 계층 IP : 각 패킷의 주소부분을 처리하여 패킷들이 목적지에 정확하게 도달할 수 있도록함.

### _계층을 나누는 이유?_

통신이 일어나는 과정을 단계별로 파악하기 용이하여, 특정 계층에서 장애 발생하더라도 다른 계층의 장비나 소프트웨어를 건들이는 헛수고를 안할수 있다는 장점.

### **1\. 네트워크 인터페이스 계층**

OSI7계층의 물리계층과 데이터링크계층에 해당하는 계층으로, 실제로 TCP/IP 패킷을 주고받는 계층이다. <br>
통신시 MAC주소를 사용하며, 수행하는 기능으로는 에러 검출, 패킷의 프레임화 등이 있다.<br>
자세한 특징은 아래 OSI 7계층의 물리, 데이터링크 계층에서 각각 설명.

**`물리 계층 (단위: 비트)`**

컴퓨터와 네트워크 장비를 연결하고 장치간 전송되는 데이터를 전기 신호로 변환( 비트->전기신호, 전기신호->비트)<br>
유선과 무선이 있으며, 유선이 일반적이다.<br>
흔히 쓰이는 UTP케이블을 예로 들수있음.

대표적인 장비로는 랜카드, 리피터, AP, 허브 등이 있다.

**\-NIC**: 0과 1만으로 이루어진 비트열을 랜카드로 전송하여 전기 신호로 변환(데이터 송수신)  
 유선 랜카드, 무선 랜카드 있음.

**\-리피터**: 약해진 신호를 증폭하여 다른쪽으로 전달.  
먼 거리에 신호가 가야할때, 중간에 리피터 배치하여 중계하도록 할때 쓰임

**\-AP(Access Point)**: 무선 기기들은 AP에게 무선신호를 전송하고, AP는 해당 신호를 유선신호로 변환하여 네트워크에 전달. 즉, 유선네트워크와 무선네트워크를 연결하는 역할을 한다.

2.4Ghz/5Ghz의 무선신호가 저절로 utp cable 구리동선으로 들어가서 신호가 변환이 되어 갈 수는 없으므로.

그렇다면 핸드폰에서 WIFI접속하여 '네이버주소'를 입력하면?

\--> 휴대폰이 검색명령을 무선신호로 AP에게 전송한다.

AP는 해당 신호를 유선신호로 변환하여 유선네트워크로 전달하고, 유선네트워크에서 검색결과를 받아 무선신호로 변환하여 다시 휴대폰에 전송함.

**`데이터링크 계층 (단위: 프레임)`**

'직접 연결된' 서로 다른 2개의 네트워크 장치간 데이터전송을 담당. <br>
데이터 링크 계층에서는 말 그대로 직접 연결된 장치와 통신만 생각한다. 그 외의 통신관련 문제는 해당 계층에서는 고려x <br>
즉, 물리 계층에서 사용되는 장비를 이용하여 호스트 사이의 연결 및 데이터 전송 기능과 관리를 하는 계층이다.

**MAC Address** 가지고 통신.<br>
우리가 흔히 아는 ip주소간의 통신은 이 MAC주소의 통신의 연속된 과정이라고 볼수있다.<br>
MAC주소는 컴퓨터나 노트북에 있는 LAN카드를 구별하기 위한 식별번호라고 한다.(물리적 주소)

수행하는 서비스로는

\- 프레이밍 : 데이터 배열에 Data, Header, Trailer 등을 넣어서 캡슐화(Encapsulate) 진행

\- 흐름제어 : 송신자와 수신자의 처리 속도간의 차이를 해결하기 위한 제어. (송신 측이 수신 측의 데이터 처리속도보다 빠른 속도로 데이터를 보낸다면 버퍼가 길어질 것이며, 버퍼의 길이는 제한되어있으므로)

\- 에러확인 : 에러를 검출하는 방법에는 직접 수정하는 방법과 수신받은 데이터배열을 폐기하고 송신측에 데이터를 재요청 하는 방법이 있다.

이더넷 프레임을 통해 에러확인, 흐름제어, 접근제어 등을 수행 <br>
대표 장비로 브리지, 스위치가 있음.

**\-스위치**: 장치들의 MAC주소를 맥 주소 테이블로 관리. 패킷 전송을 담당.

**\-브리지**: 두개의 LAN을 상호 접속 할수있도록 연결.  
 포트와 포트 사이의 다리 역할.

프로토콜 종류: Ethernet 등이 있다.

### **2\. 인터넷 계층**

가장 중요한 기능은 **Routing(경로설정: 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능)**

그외에도 Addressing(IP주소부여), packaging 이 있다.

네트워크상 최종 목적지까지 정확하게 연결되도록 연결성을 제공한다.

프로토콜 종류: IP, ARP, RARP, ICMP

**`네트워크 계층 (OSI) (단위: 패킷)`**

원하는 곳으로 잘보내고 있는지, 효율적인 방법으로 보내는지 어떻게 보장하느냐? --> 이거를 네트워크 계층이 담당한다. <br>

ip주소는 데이터 통신시의 시작점과 끝점을 의미,<br>
MAC주소는 직접적으로 연결된 노드와 통신할때 사용되는 주소.

프로토콜 종류 : IP, ARP, RARP

**라우터**: 일종의 지능이 있는 경로 배정기

**공유기** : 2개의 서로 다른 네트워크를 연결.

공인 ip주소를받아서 연결되는 실제 네트워크와 가상으로 192.168.x.x 주소를 부여하는 사설 네트워크(LAN)를 연결시켜서 사설 네트워크에 연결된 pc가 실제 인터넷에 연결되게 한다.

일종의 NAT기능 DHCP기능 추가된 라우터

**무선공유기**: 유선공유기+ap느낌 (ap는 nat기능 없음)

### **3\. 전송 계층**

프로토콜 종류: TCP, UDP

단위: 세그먼트, 데이터그램

### **4\. 애플리케이션 계층**

OSI 7계층의 세션,표현,응용 계층에 해당

사용자를 위한 UI 인터페이스 소프트웨어, 입출력 부분 등을 담당한다.

프로토콜 종류: FTP, HTTP, SSH, SMTP, DNS

## HTTP

사용자와 직접 상호작용하는 애플리케이션 계층의 프로토콜로 웹서비스 통신에 이용된다.

- HTTP/1.0
  비지속 연결. (하나의 연결당 하나의 요청만을 처리)
  => 서버로부터 파일을 가져올때마다 TCP 3-way handshake를 해서 RTT가 증가

해결방법: 이미지 스플리팅(스프라이트 이미지), 코드압축 등

- HTTP/1.1
  Keep-Alive 옵션 (한번의 TCP 연결후, 여러개의 파일 송수신 가능)

  문제점

  1. 헤더의 중복
  2. HOL Blocking
  3. 클라이언트 요청이 없으면 서버는 먼저 데이터 전송 못함.

- HTTP/2
  헤더 압축
  멀티플렉싱 (여러개의 스트림을 사용함으로써 HOLB 해결)
  서버푸시 (서버가 리소스를 직접 푸시할 수 있음 => 전송시간 단)

### 문제

- google.com 은 URL이다. (⭕/❌)
- HTTP 응답이 최종적으로 브라우저에 도달하면, TCP 연결을 종료한다. (⭕/❌)
